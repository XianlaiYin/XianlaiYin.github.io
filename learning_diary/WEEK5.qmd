# **WEEK 5** {.unnumbered}

#### ***An introduction to Google Earth Engine*** {.unnumbered}

> This is a learning diary of CASA0023 WEEK 5, the lecture presentation is [here](https://andrewmaclachlan.github.io/CASA0023-lecture-5/#1), and the practical material is [here](https://andrewmaclachlan.github.io/CASA0023/5_GEE_I.html).

## **1 Summary: lecture**

This week's content is an introduction to the basics of GEE, including its features, functions and application scenarios. It also introduces the use of the basic functions of GEE Javascript in relation to R, such as loading image collections, reducing images, regression, joins and filtering.

![Mindmap of Week 5 Leacture](img/WEEK5_Mindmap.svg){width="100%"}

------------------------------------------------------------------------

### **1.1 The setup of GEE**

#### **Google Earth Engine** {.unnumbered}

```{r, echo = FALSE, out.width='100%'}
xaringanExtra::embed_xaringan(
  url = "https://www.youtube.com/embed/gKGOeTFHnKY",
  ratio = "16:9")
```

- `"Geospatial"` processing service
- It permits geospatial analysis `at scale`
- Stores data on servers
- Takes the code and applies it
- Can be used to make `queryable online applications`

:::callout-tip

#### GEE terms {.unnumbered}

- `Image` = raster
- `Feature` = vector
- `Image stack` = ImageCollection
- `Feature stack` (lots of polygons) = FeatureColletion
:::

#### **GEE Javascript** {.unnumbered}

***GEE uses Javascript (Website programming language)***

There are some similarities to python and R but there are some notable differences

- Variables (or objects) as defined with var
- A specific part of code ends with a ;
- Objects are dictionaries in Javascript
	
#### **Client vs server side** {.unnumbered}

- Within GEE we have code that runs on the `client side (browser)`
- We have code that runs on the server side (on the server where data is stored)
- In GEE we have `Earth Engine Objects` = starting with , for example, `ee`
	- Anything that has ee **in front of it is stored on the server**
	- It has no data in script. Recall in R the data environments, this would be empty
	- They are termed `"proxy objects"`: the agency, function, or office of a deputy who acts as a substitute for another
	- Any pre-loaded data product will be on the server side

***Looping***

- We can't (or shouldn't) use a loop for something on the server
- The loop doesn't know what is in the ee object

***Mapping functions***

- Instead we can create a function and save it into an object (or variable here)
- Then apply it to everything on the server
- Same idea as `map()` in R from the purrr package

***Server side functions***

- Same as the data
- `ee.Thing.method()`
- Saved function on the sever that can be run without mapping

#### **Loop vs Map** {.unnumbered}

***Loop***

- Run some code on each element in an array
- Save it in a new array (or update existing)

***Map***

- Code is applied to each element
- The conditions are dealt with, `no indexing` at the end

***Why map in GEE?***

- Otherwise we might load the complete image collection many, many times when looping
- The loop doesn't know what is inside the collection
- Mapping lets GEE allocate the the processing to different machines with map. I assume as it knows how many images we have and the function it must apply...With a loop it doesn't know until the next interation

#### **Scale** {.unnumbered}

- Image scale in GEE refers to `pixel resolution`
- In GEE the scale (resolution) is set by the **output not input**
- When doing analysis
	- GEE aggregates the image to fit a `256x256 grid`
	- Earth Engine selects the pyramid with the closest scale to that of analysis (or specified by it) and resamples as needed
	- resampling uses `nearest neighbor` by default

#### **Projections** {.unnumbered}

- Do not need to worry about projects in GEE
- GEE converts all data into the `Mercator projection (EPSG: 3857)` when displayed, specifically: WGS 84 / Pseudo-Mercator -- Spherical Mercator, Google Maps, OpenStreetMap, Bing, ArcGIS, ESRI
- The operations of the proejction are determined by the output
- Setting the projection is allowed, but there is no real reason to do this

### **1.2 GEE in action**

#### **Building blocks of GEE** {.unnumbered}

![Object classes. Source: [GEE](https://developers.google.com/earth-engine/guides/objects_methods_overview)](img/GEE_object_classes.png){width="100%"}

***Object: vector, raster, feature, string, number***

- Each of these belongs to a `class`
- Each class has specific `GEE functions` (or methods) for it

***Raster data (lots of images)***

- They belong to an `image collection` (as there are lots of images)
- Using the specific function (`method` or `"constructor"`) to load and manipulate

***Geometries and Features***

- `Geometry` = point/line/polygon with no attributes
	- *Note we can also have MultiPolygon or MultiGeometry*
- `Feature` = geometry with attributes
- `Feature` collection = several features with attributes

#### **What typical processes can do in GEE?** {.unnumbered}

![What does GEE look like. Source: [lecture](https://andrewmaclachlan.github.io/CASA0023-lecture-5/#31)](img/Code_editor_diagram.png){width="100%"}

***Geometry operations (e.g. spatial operations)***

- `Joins`
- `Zonal statistics` (e.g. average temperature per neighbourhood)
- `Filtering` of images or specific values

***Methods***

- `Machine learning`
- Supervised and unsupervised `classification`
- `Deep learning` with Tensor Flow
- Exploring relationships between variables

***Applications/outputs***

- Online charts
- Scalable geospatial applications with GEE data
- These let us query the data with a user inteface that then updates the results

#### **Reducing images** {.unnumbered}

***This is combines the previous two ideas***

- In the first instance we load an image collection from a dates and place
- We want to reduce the collection to the extreme values for each pixel

***Reducing images by region***

- One of the most useful functions we can use here is termed zonal statistics
- In GEE this is termed `reduceRegion()`
- What if we want to use a feature collection (with many polygons), same idea, but with `image.reduceRegions()`

***Reducing images by neighbourhood***

- Instead of using a polygon to reduce our collection we can use the `image neighbourhood`
	- A window of pixels surrounding a central pixel
	- Like a filter or texture measure
	- Although texture has its own function

#### **Linear regression** {.unnumbered}

The real benefit of GEE is being able to access all imagery for multiple sensors, what if we wanted to see the change over time in pixel values - `linearFit()`

- `linearFit()` takes a least squares approach of one variable. 2 bands:
	- Band 1: dependent variable
	- Band 2: independent variable (often time)
- This runs of a `per pixel` basis
- This is still considered a `reducer` as we are reducing all of the data to two images
	- `Offset` - intercept
	- `Scale` - line of the slope
We can use additional variables like we have seen before, including multiple dependent variables...this is termed `Multivariate Multiple Linear Regression`. This just does the same as OLS for both of the dependent variables, the only difference is with a `covariance matrix`.

***We can combine reducers for regression***
- Regression per pixels (typically with an image collection over several years)
- Regression of all the values within a polygon (taking an image of 1 date, extracting all the pixels and then running regression)
- In GEE we must add a constant as an independent variable for the intercept (unless it is 0)

#### **Joins** {.unnumbered}

***Joins in GEE are similar to joins in R***

- We can join image collections (e.g. satellite data from January with data from October)
- We can join feature collections (e.g. different polygons)

***To use joins we have to put them within a filter (ee.Filter)***

- The `leftField` is the index (or attribute) in the primary data
- The `rightField` is the secondary data
- We set the type of join
	- simple: primary matches any in secondary
	- inverted: retain those in primary that are not in secondary
	- inner: shows all matches between collections as a feature collection
- We then combine (or join) with `join.apply()`

***GEE can also do a spatial join and intersect***

## **2 Summary: practical**

> This week's practical will consist mainly of the following:
>
> -   Introduction and access to Landsat data
> -   A deeper understanding of atmospheric correction and how it works in practice
> -   Introduction to the principles of Radiance (or DN) to Reflectance
> -   Practical exercises in image joining
> -   A deep understanding of image enhancement and how it works in practice

For this week's practical I chose to follow the guidance using Landsat data from Cape Town. I used R to do atmospheric corrections, merging, data enhancement and other operations on the data. Through practical, I gained a better understanding of remote sensing data pre-processing and was able to apply this to my workflow in R. Combined with the previous term's CASA0005 course, I can now use R to analyse more types of data.

![Texture of landsat data from Cape Town](img/my_plot.png){width="100%"}

## **3 Application**

> This week, the main focus was on the correction, joining and enhancement of remote sensing images, mostly applied to pre-processing before analysis, but remote sensing image enhancement has a wider range of applications.

### **3.1 Applications of remote sensing image enhancement**

### **3.2 Application case**

::: callout-tip
#### Sourse {.unnumbered}

***PCA‐based land‐use change detection and analysis using multitemporal and multisensor satellite data*** , *Sourse: @deng_pcabased_2008*
:::

### **3.3 Case comments**

***Advantages or contribution***

***Disadvantages or potential***

## **4 Reflection**